## lynchip sdk python接口编程分享

> 大纲
>
> 1. pybind11封装C接口的注意事项
>    多返回值处理；变量的生存周期；全局解释锁
> 2. python基础语法：变量，模块，数据结构（list，tuple），类，格式化输出
> 3. numpy使用：array，数据读取与保存
> 4. SDK python接口后期改进点：面向对象编程



### 1. python基础语法

#### 1.1 变量



#### 1.2 格式化输出



#### 1.3 数据结构



#### 1.4 类



### 2. pybind11封装C接口的注意事项

#### 2.1 不要将函数参数作为出参

在C语言中，如果需要返回多个值，通常是使用指针作为入参来完成多返回值的功能。而python天然支持多返回值；且python的基础类型（str, int, bool, float, etc.）属于不变值，这意味着像C语言通过指针作为出参的方法对于python的不变类型是不起作用的。

因此，针对C语言多返回值的函数，我们需要对绑定函数做一层封装，通过调用tuple类型来实现多返回值。

```C++
int foo(int& i) { i++; return 123;}
m.def("foo", [](int i) {
    int rv = foo(i);
    return std::make_tuple(rv, i);
});
```

#### 2.2 指针的处理

python中没有指针的概念，但是向之前说的，python中的变量其实本质是引用。所以，在pybind11将C接口转换为python接口时，指针被转换成了对应的类型，如`int *`变量被转换成了`int`类型的python变量。其中有两个例外的，就是`void *`和`char *`。

`void *`被转换成了PyCapsule类型，capsule类型代表一个opaque（不明的）值，适用于需要将不明值（作为`void*`指针）通过Python代码传递到其他C代码的C扩展模块中去。这并不是python常用的类型，仅提供最基础的几个内置方法，基本在python编程中无法与其他变量和方法交互。

`char *`类型，pybind11对其做了特殊处理，在python端它被转换为了str字符串类型。

为方便处理，我们将SDK接口中指针的使用分为以下3种情况：

1. 指向单个对象，作为入参传入函数中，函数执行过程中，其指向的值不会发生变化；
2. 指向单个对象，作为入参传入函数中，函数执行过程中，其指向的值会发生变化；
3. 指针指向一块内存。

对于第一种情况，在使用pybind11转换时，不需要做任何处理，即使去掉指针也不影响函数正常运行。

对于第二种情况，针对不变类型，需要将其转换为多返回值处理；对于可变类型，虽然能够正常运行，也推荐尽量通过多返回值处理（特别是C中先创建一个变量，再将变量通过指针传入函数的情况）。

对于第三种情况，python中没有对应的语法（主动申请内存，地址移位操作），所以我们需要借助第三方库numpy与PyCapsule类型来实现对内存的操作。

#### 2.3 变量的生存周期



#### 2.4 避免因全局解释锁而产生死锁





### 3. numpy的使用







