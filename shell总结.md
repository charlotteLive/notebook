## shell总结

Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。

### 1. shell变量

#### 1.1 shell变量的基本规则

shell变量的命名规则：

- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
- 中间不能有空格，可以使用下划线 **_**。
- 不能使用标点符号。
- 不能使用bash里的关键字（可用help命令查看保留关键字）。

使用一个定义过的变量，只要在变量名前面加美元符号即可。变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界。

```shell
for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done
```

如果不给skill变量加花括号，写成`echo "I am good at $skillScript"`，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。

**只读变量**：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

运行shell时，会同时存在三种变量：

- **1) 局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
- **2) 环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
- **3) shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。

#### 1.2 shell字符串

字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。

- 使用单引号时，**单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的**；单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

- 而使用双引号时，**引号中可以使用变量，且可以出现转义字符**。

**获取字符串的长度**：

```shell
string="abcd"
echo ${#string} #输出 4
```

**提取子字符串**：

```shell
string="runoob is a great site"
echo ${string:1:4} # 输出 unoo
```

> **注意**：第一个字符的索引值为 **0**。

**查找子字符串**：

查找字符 **i** 或 **o** 的位置(哪个字母先出现就计算哪个)：

```shell
string="runoob is a great site"
echo `expr index "$string" io`  # 输出 4
```

#### 1.3 shell数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。

在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。如：

```shell
array_name=(value0 value1 value2 value3)
```

读取数组元素值的一般格式是`${数组名[下标]}`，使用 **@** 符号可以获取数组中的所有元素，例如：

```shell
valuen=${array_name[n]}
echo ${array_name[@]}     #获取数组中的所有元素

length=${#array_name[@]}  #取得数组元素的个数
length=${#array_name[*]}  #取得数组元素的个数
lengthn=${#array_name[n]} #取得数组单个元素的长度
```

#### 1.4 shell传递参数

我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字， **$0** 为执行的文件名（包含文件路径），**$1**为执行脚本的第一个参数，**$2** 为执行脚本的第二个参数，以此类推……

```sh
echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";
```

另外，还有几个特殊字符用来处理参数：

| 参数处理 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| `$#`       | 传递到脚本的参数个数                                       |
| `$* `      | 以一个单字符串显示所有向脚本传递的参数。 如`"$*"`用「"」括起来的情况、以`"$1 $2 … $n"`的形式输出所有参数。 |
| `$$`      | 脚本运行的当前进程ID号                                 |
| `$!`       | 后台运行的最后一个进程的ID号                           |
| `$@`       | 与`$*`相同，但是使用时加引号，并在引号中返回每个参数。 如`"$@"`用「"」括起来的情况、以`"$1" "$2" … "$n"` 的形式输出所有参数。 |
| `$-`       | 显示Shell使用的当前选项，与set功能相同。 |
| `$?`      | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

`$*` 与 `$@`的区别：

- 相同点：都是引用所有参数。
- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则` "*" `等价于 "1 2 3"（传递了一个参数），而` "@" `等价于 "1" "2" "3"（传递了三个参数）。

### 2. shell基本运算符

#### 2.1 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                  | 举例                         |
| :----- | :---------------------------------------------------- | :--------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | `[ $a -eq $b ] `返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | `[ $a -ne $b ]` 返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | `[ $a -gt $b ] `返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | `[ $a -lt $b ] `返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | `[ $a -ge $b ] `返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[ $a -le $b ] `返回 true。  |

#### 2.2 逻辑运算符

| 运算符 | 说明       | 举例                                        |
| :----- | :--------- | :------------------------------------------ |
| &&     | 逻辑的 AND | `[[ $a -lt 100 && $b -gt 100 ]]` 返回 false |
| \|\|   | 逻辑的 OR  | `[[ $a -lt 100 || $b -gt 100 ]]` 返回 true  |
| !      | 非运算     | `[ ! false ]` 返回 true。                   |

#### 2.3 字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                       |
| :----- | :------------------------------------------- | :------------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | `[ $a = $b ] `返回 false。 |
| !=     | 检测两个字符串是否不相等，不相等返回 true。  | `[ $a != $b ] `返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | `[ -z $a ] `返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | `[ -n "$a" ] `返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | `[ $a ]` 返回 true。       |

#### 2.4 文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性。

| 操作符  | 说明                                                     | 举例                        |
| :------ | :------------------------------------------------------- | :-------------------------- |
| -b file | 检测文件是否是块设备文件。                               | `[ -b $file ] `返回 false。 |
| -c file | 检测文件是否是字符设备文件。                             | `[ -c $file ] `返回 false。 |
| -d file | 检测文件是否是目录。                                     | `[ -d $file ] `返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件）。   | `[ -f $file ] `返回 true。  |
| -g file | 检测文件是否设置了 SGID 位。                             | `[ -g $file ] `返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)。                   | `[ -k $file ] `返回 false。 |
| -p file | 检测文件是否是有名管道。                                 | `[ -p $file ] `返回 false。 |
| -u file | 检测文件是否设置了 SUID 位。                             | `[ -u $file ]` 返回 false。 |
| -r file | 检测文件是否可读。                                       | `[ -r $file ] `返回 true。  |
| -w file | 检测文件是否可写。                                       | `[ -w $file ] `返回 true。  |
| -x file | 检测文件是否可执行。                                     | `[ -x $file ] `返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。 | `[ -s $file ] `返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。      | `[ -e $file ] `返回 true。  |

举个例子：

```shell
file="/var/www/runoob/test.sh"
if [ -r $file ]
then
   echo "文件可读"
else
   echo "文件不可读"
fi

if [ -f $file ]
then
   echo "文件为普通文件"
else
   echo "文件为特殊文件"
fi
```

### 3. 流程控制

#### 3.1 if-else语句

```bash
a=10
b=20
if [ $a == $b ]
then
   echo "a 等于 b"
elif [ $a -gt $b ]
then
   echo "a 大于 b"
elif [ $a -lt $b ]
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi
```

#### 3.2 for循环

```bash
for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
```

当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。

in列表是可选的，如果不用它，for循环使用命令行的位置参数。

**bash 2.04 版开始引入一种 for 循环的变体，语法与 C 语言类似**。其一般形式如下所示。

```bash
for (( expr1 ; expr2 ; expr3 ))
do
	list
done
```

双括号表明这是算术表达式，在其中引用变量时，不用加 $（但 $1 等位置参数除外），只要是 bash 中出现双括号的地方，均是如此。该表达式是整数表达式，可以使用包括逗号（用于在一个表达式中放入多个操作）在内的大量运算符。

```bash
for (( i=0, j=0 ; i+j < 10 ; i++, j++ ))
do
	echo $((i*j))
done
```

#### 3.3 while语句

```bash
int=1
while(( $int<=5 ))
do
    echo $int
    let "int++"
done
```

以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。

break命令允许跳出所有循环（终止执行后面的所有循环）。

continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。

不写条件，或者条件给定为true，表示无限循环。

```bash
while :
do
    echo -n "输入 1 到 5 之间的数字: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的!"
            continue
            echo "游戏结束"
        ;;
    esac
done
```

#### 3.4 case语句

```bash
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac
```

case 工作方式如上所示，取值后面必须为单词 **in**，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 **;;**。

取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号` * `捕获该值，再执行后面的命令。

### 4. 函数

#### 4.1 函数定义

linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。

```bash
funWithReturn(){
    echo "这个函数会对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "
    read aNum
    echo "输入第二个数字: "
    read anotherNum
    echo "两个数字分别为 $aNum 和 $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "输入的两个数字之和为 $? !"
```

说明：

- 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
- 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255

#### 4.2 函数参数

在Shell中，调用函数时可以向其传递参数。在函数体内部，通过` $n` 的形式来获取参数的值，例如，`$1`表示第一个参数，`$2`表示第二个参数...

```bash
funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
```

注意，`$10` 不能获取第十个参数，获取第十个参数需要`${10}`。当n>=10时，需要使用`${n}`来获取参数。

另外，还有几个特殊字符用来处理参数：

| 参数处理 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| `$#`     | 传递到脚本或函数的参数个数                                   |
| `$*`     | 以一个单字符串显示所有向脚本传递的参数                       |
| `$$`     | 脚本运行的当前进程ID号                                       |
| `$!`     | 后台运行的最后一个进程的ID号                                 |
| `$@`     | 与`$*`相同，但是使用时加引号，并在引号中返回每个参数。       |
| `$-`     | 显示Shell使用的当前选项，与set命令功能相同。                 |
| `$?`     | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

### 5. 输入输出重定向



### 6. shell脚本编程经典实例

#### 6.1 无人值守下运行耗时作业

如果想在后台运行作业并在该作业完成前退出 shell，那就需要对作业使用 nohup。

```bash
root@ubuntu:~$ nohup tail -f examples.desktop &
[1] 2812
root@ubuntu:~$ nohup: ignoring input and appending output to 'nohup.out'
```

将作业置入后台时，它仍旧是 bash shell 的子进程。如果退出 shell 的某个实例，bash 就会向其所有子进程发送 hangup 信号。这就是作业运行不了多久的原因。只要退出bash，后台作业就会被“杀死”。

nohup 命令只是设置子进程忽略 hangup 信号。你仍可以用 kill 命令“杀死”作业，因为 kill 发送的是 SIGTERM 信号，而非 SIGHUP 信号。但有了 nohup，作业就不会在退出 bash 时被无意间“杀死”。

nohup 会替你重定向输出，将其追加（不是覆盖，而是添加到文件现有内容的末尾）到当前目录下的 nohup.out 文件中。你也可以明确地在命令行上指定将输出重定向到其他地方。

#### 6.2 减少if语句的数量

**当前命令执行成功时，才执行下一条指令**

在 bash 中使用` && `运算符，根据条件执行命令。

```bash
cd mytmp && rm * -rf
```

用 `&& `分隔两个命令，以此告诉 bash 先执行第一个命令，如果该命令成功（退出状态为 0），再执行第二个命令。这非常类似于用 if 语句检查第一个命令的退出状态，从而判断是否执行第二个命令。

**出现故障时，显示错误信息**

与`&&`类似，`||`表示前一个命令执行失败后，才执行后面的命令，通常用于故障时显示错误信息。

```bash
cmd || printf "%b" "cmd failed."
```

警告！千万别被下面这条语句骗了。

```shell
cmd || printf "%b" "cmd failed.";exit 1
```

exit无论如何都不会执行！`||` 仅作用于前两个命令。如果只想在 cmd 出错时执行 exit，那么要将其与 printf 分组到一起，以便两者被视为一个单元。语法如下所示：

```bash
cmd || { printf "%b" "cmd failed.";exit 1; }
```

注意，最后一个命令必须以分号结尾，闭合花括号与其中的内容之间要用空白字符分隔。

**获取默认值**

有一个可以接受命令行参数的 shell 脚本。你希望能够提供默认值，这样就不用每次都让用户输入那些频繁用到的值了。

用` ${:-} `语法引用参数并提供默认值。

```bash
FILE_DIR=${1:-/tmp}
```

在引用 shell 变量时，有多种特殊运算符可用。`:- `运算符的意思是，如果指定参数（这里是 `$1`）不存在或为空，则将运算符之后的内容（本例为 /tmp）作为值。否则，使用已经设置好的参数值。该运算符可用于任何 shell 变量，并不局限于位置参数（`$1`、`$2`、`$3`等），但后者是最常用到的。

**对不存在的参数输出错误信息**

引用参数时使用 `${:?}` 语法。如果指定参数不存在或为空，那么 bash 会输出错误消息并退出。

```bansh
FILE_DIR=${1:? "Error, you must supply a scratch directory."}
```

#### 6.3 在shell脚本中执行算术操作

用` $(( )) `或` let` 进行整数运算。

```bash
COUNT=$((COUNT + 5 + MAX + 2))
let COUNT+='5+MAX+2'
```

$(( )) 表达式内不需要使用空格，不过在运算符和操作数两边加上空格也无妨。但是 = 两边绝不能出现空格，这和 bash 变量赋值的规则一样。

另外，确保给 let 的表达式加上引号，因为 let 语句是 bash 内建的，其参数要经过单词扩展。

另一个怪异之处是，通常出现在 shell 变量前表示取值的 `$ `符号（如` $COUNT` 或`$MAX`）在双括号内部是不需要的。但如果用到了位置参数（如 `$2`），那么` $ `还是少不了的，因为只有这样才能区分位置参数与数字常量

let 语句和` $(( ))` 语法的另一处重要区别在于两者处理空白字符（空格字符）的方式不同。对 let 语句来说，要么添加引号，要么赋值运算符（=）和其他运算符两边不能出现空格。必须将运算符和操作数放在一起形成一个单词。以下两种写法都没问题。

```bash
let i=2+2
let "i = 2 + 2"
```

`$(( )) `语法就宽松多了，它允许各种空白字符出现在双括号内。这种写法不易出错，代码的可读性也要好得多，是我们执行 bash 整数运算时的首选方式。

#### 6.4 解析命令行参数

getopts 的设计目标是在循环中运行，每次执行循环，getopts 就检查下一个命令行参数，并判断它是否合法。即检查参数是否以` -` 开头，后面跟一个包含在 options 中的字母。如果是，就把匹配的选项字母存在指定的变量 variable 中，并返回退出状态0；如果` -` 后面的字母没有包含在 options 中，就在 variable 中存入一个 ？，并返回退出状态0；如果命令行中已经没有参数，或者下一个参数不以`-`开头，就返回不为0的退出状态。

**getopts引用的三个环境变量：**

- **OPTARG**: 上一个由getopts内置命令处理的选项参数的值， option argument（存放选项参数），当选项需要选项参数时，getopts 命令就将其置于变量 OPTARG 中

- **OPTIND**:  下一个由getopts内置命令处理的参数的序号，option index，每次调用脚本它都会被初始值为1，会逐次递增。

- **OPTERR**: 如果设为1，bash会显示getopts的错误。设为0,不显示getopts的错误。

**getopts 的处理过程：**
　　调用脚本时，OPTIND为初始化为1。每调用一次getopts，就将下一个选项值赋给name , 选项索引值OPTIND也会指向下一个要处理选项的位置，选项参数则会赋给OPTARG
　　getopts 的设计目标是在循环中运行，每执行一次，getopts就检查下一个命令行参数，并判断它是否有效。（即检查参数是否以-开头，后面跟一个包含在opstring中的字母）。
　　有效，则把匹配的选项字母存在指定的变量variable中，并返回退出状态0（ture）；
　　无效(如果-后面的字母没有包含在options)，就在 variable 中存入一个？，并返回退出状态0；如果命令行中已经没有参数，或者下一个参数不以-开头，就返回不为0的退出状态(false, 可用于结束while 循环)。
　getopts处理完所有参数后，会返回一个非0值（false,退出循环），此时OPTIND索引值指向第一个非选项的参数[args],name置为?

**getopts 错误处理**
　　正确使用命令时，name用来存储option, $OPTARG用来存放option的参数。若命令输入有误（选项无效，缺少参数），getopts会处理illegal option错误和miss option argument错误。处理结果与opstring是否以：开头而不同。opstring 开头的：用于屏蔽getopts处理时的错误消息（脚本中将OPTERR置于0也可以达到同样的效果）。

```bash
#!/bin/bash
while getopts u:p:n option
do 
    case "$option" in
        u)
            echo "option:u, value $OPTARG"
            echo "next arg index:$OPTIND";;
        p)
            echo "option:p"
            passwd=$OPTARG
            echo "next arg index:$OPTIND"
            echo "PASSWD IS: $passwd";;
        n)
            echo "option:N"
            echo "next arg index:$OPTIND";;
        \?)
            echo "Usage: args [-U] [-p] [-n]"
            echo "-u means uses"
            echo "-p means passwd"
            echo "-n means name"
            exit 1;;
    esac
done
```

注：

1.getopts 允许把选项堆叠在一起（如 -ms）

2.如要带参数，须在对应选项后加 :（如h后需加参数 h:ms）。此时选项和参数之间至少有一个空白字符分隔，这样的选项不能堆叠。

3.如果在需要参数的选项之后没有找到参数，它就在给定的变量中存入 **?** ，并向标准错误中写入错误消息。否则将实际参数写入特殊变量 ：**OPTARG**

4.另外一个特殊变量：**OPTIND**，反映下一个要处理的参数索引，初值是 1，每次执行 getopts 时都会更新。