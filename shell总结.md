## shell总结

Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。

### 1. shell变量

#### 1.1 shell变量的基本规则

shell变量的命名规则：

- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
- 中间不能有空格，可以使用下划线 **_**。
- 不能使用标点符号。
- 不能使用bash里的关键字（可用help命令查看保留关键字）。

使用一个定义过的变量，只要在变量名前面加美元符号即可。变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界。

```shell
for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done
```

如果不给skill变量加花括号，写成`echo "I am good at $skillScript"`，解释器就会把$skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。

**只读变量**：使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。

运行shell时，会同时存在三种变量：

- **1) 局部变量** 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。
- **2) 环境变量** 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。
- **3) shell变量** shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行。

#### 1.2 shell字符串

字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。

- 使用单引号时，**单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的**；单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

- 而使用双引号时，**引号中可以使用变量，且可以出现转义字符**。

**获取字符串的长度**：

```shell
string="abcd"
echo ${#string} #输出 4
```

**提取子字符串**：

```shell
string="runoob is a great site"
echo ${string:1:4} # 输出 unoo
```

> **注意**：第一个字符的索引值为 **0**。

**查找子字符串**：

查找字符 **i** 或 **o** 的位置(哪个字母先出现就计算哪个)：

```shell
string="runoob is a great site"
echo `expr index "$string" io`  # 输出 4
```

#### 1.3 shell数组

bash支持一维数组（不支持多维数组），并且没有限定数组的大小。类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。

在 Shell 中，用括号来表示数组，数组元素用"空格"符号分割开。如：

```shell
array_name=(value0 value1 value2 value3)
```

读取数组元素值的一般格式是`${数组名[下标]}`，使用 **@** 符号可以获取数组中的所有元素，例如：

```shell
valuen=${array_name[n]}
echo ${array_name[@]}     #获取数组中的所有元素

length=${#array_name[@]}  #取得数组元素的个数
length=${#array_name[*]}  #取得数组元素的个数
lengthn=${#array_name[n]} #取得数组单个元素的长度
```

#### 1.4 shell传递参数

我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：**$n**。**n** 代表一个数字， **$0** 为执行的文件名（包含文件路径），**$1**为执行脚本的第一个参数，**$2** 为执行脚本的第二个参数，以此类推……

```sh
echo "Shell 传递参数实例！";
echo "执行的文件名：$0";
echo "第一个参数为：$1";
echo "第二个参数为：$2";
echo "第三个参数为：$3";
```

另外，还有几个特殊字符用来处理参数：

| 参数处理 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| `$#`       | 传递到脚本的参数个数                                       |
| `$* `      | 以一个单字符串显示所有向脚本传递的参数。 如`"$*"`用「"」括起来的情况、以`"$1 $2 … $n"`的形式输出所有参数。 |
| `$$`      | 脚本运行的当前进程ID号                                 |
| `$!`       | 后台运行的最后一个进程的ID号                           |
| `$@`       | 与`$*`相同，但是使用时加引号，并在引号中返回每个参数。 如`"$@"`用「"」括起来的情况、以`"$1" "$2" … "$n"` 的形式输出所有参数。 |
| `$-`       | 显示Shell使用的当前选项，与set功能相同。 |
| `$?`      | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

`$*` 与 `$@`的区别：

- 相同点：都是引用所有参数。
- 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则` "*" `等价于 "1 2 3"（传递了一个参数），而` "@" `等价于 "1" "2" "3"（传递了三个参数）。

### 2. shell基本运算符

#### 2.1 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：

| 运算符 | 说明                                                  | 举例                         |
| :----- | :---------------------------------------------------- | :--------------------------- |
| -eq    | 检测两个数是否相等，相等返回 true。                   | `[ $a -eq $b ] `返回 false。 |
| -ne    | 检测两个数是否不相等，不相等返回 true。               | `[ $a -ne $b ]` 返回 true。  |
| -gt    | 检测左边的数是否大于右边的，如果是，则返回 true。     | `[ $a -gt $b ] `返回 false。 |
| -lt    | 检测左边的数是否小于右边的，如果是，则返回 true。     | `[ $a -lt $b ] `返回 true。  |
| -ge    | 检测左边的数是否大于等于右边的，如果是，则返回 true。 | `[ $a -ge $b ] `返回 false。 |
| -le    | 检测左边的数是否小于等于右边的，如果是，则返回 true。 | `[ $a -le $b ] `返回 true。  |

#### 2.2 逻辑运算符

| 运算符 | 说明       | 举例                                        |
| :----- | :--------- | :------------------------------------------ |
| &&     | 逻辑的 AND | `[[ $a -lt 100 && $b -gt 100 ]]` 返回 false |
| \|\|   | 逻辑的 OR  | `[[ $a -lt 100 || $b -gt 100 ]]` 返回 true  |
| !      | 非运算     | `[ ! false ]` 返回 true。                   |

#### 2.3 字符串运算符

下表列出了常用的字符串运算符，假定变量 a 为 "abc"，变量 b 为 "efg"：

| 运算符 | 说明                                         | 举例                       |
| :----- | :------------------------------------------- | :------------------------- |
| =      | 检测两个字符串是否相等，相等返回 true。      | `[ $a = $b ] `返回 false。 |
| !=     | 检测两个字符串是否不相等，不相等返回 true。  | `[ $a != $b ] `返回 true。 |
| -z     | 检测字符串长度是否为0，为0返回 true。        | `[ -z $a ] `返回 false。   |
| -n     | 检测字符串长度是否不为 0，不为 0 返回 true。 | `[ -n "$a" ] `返回 true。  |
| $      | 检测字符串是否为空，不为空返回 true。        | `[ $a ]` 返回 true。       |

#### 2.4 文件测试运算符

文件测试运算符用于检测 Unix 文件的各种属性。

| 操作符  | 说明                                                     | 举例                        |
| :------ | :------------------------------------------------------- | :-------------------------- |
| -b file | 检测文件是否是块设备文件。                               | `[ -b $file ] `返回 false。 |
| -c file | 检测文件是否是字符设备文件。                             | `[ -c $file ] `返回 false。 |
| -d file | 检测文件是否是目录。                                     | `[ -d $file ] `返回 false。 |
| -f file | 检测文件是否是普通文件（既不是目录，也不是设备文件）。   | `[ -f $file ] `返回 true。  |
| -g file | 检测文件是否设置了 SGID 位。                             | `[ -g $file ] `返回 false。 |
| -k file | 检测文件是否设置了粘着位(Sticky Bit)。                   | `[ -k $file ] `返回 false。 |
| -p file | 检测文件是否是有名管道。                                 | `[ -p $file ] `返回 false。 |
| -u file | 检测文件是否设置了 SUID 位。                             | `[ -u $file ]` 返回 false。 |
| -r file | 检测文件是否可读。                                       | `[ -r $file ] `返回 true。  |
| -w file | 检测文件是否可写。                                       | `[ -w $file ] `返回 true。  |
| -x file | 检测文件是否可执行。                                     | `[ -x $file ] `返回 true。  |
| -s file | 检测文件是否为空（文件大小是否大于0），不为空返回 true。 | `[ -s $file ] `返回 true。  |
| -e file | 检测文件（包括目录）是否存在，如果是，则返回 true。      | `[ -e $file ] `返回 true。  |

举个例子：

```shell
file="/var/www/runoob/test.sh"
if [ -r $file ]
then
   echo "文件可读"
else
   echo "文件不可读"
fi

if [ -f $file ]
then
   echo "文件为普通文件"
else
   echo "文件为特殊文件"
fi
```

### 3. 流程控制

#### 3.1 if-else语句

```bash
a=10
b=20
if [ $a == $b ]
then
   echo "a 等于 b"
elif [ $a -gt $b ]
then
   echo "a 大于 b"
elif [ $a -lt $b ]
then
   echo "a 小于 b"
else
   echo "没有符合的条件"
fi
```

#### 3.2 for循环

```bash
for loop in 1 2 3 4 5
do
    echo "The value is: $loop"
done
```

当变量值在列表里，for 循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的 shell 命令和语句。in 列表可以包含替换、字符串和文件名。

in列表是可选的，如果不用它，for循环使用命令行的位置参数。

#### 3.3 while语句

```bash
int=1
while(( $int<=5 ))
do
    echo $int
    let "int++"
done
```

以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。

break命令允许跳出所有循环（终止执行后面的所有循环）。

continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。

不写条件，或者条件给定为true，表示无限循环。

```bash
while :
do
    echo -n "输入 1 到 5 之间的数字: "
    read aNum
    case $aNum in
        1|2|3|4|5) echo "你输入的数字为 $aNum!"
        ;;
        *) echo "你输入的数字不是 1 到 5 之间的!"
            continue
            echo "游戏结束"
        ;;
    esac
done
```

#### 3.4 case语句

```bash
echo '输入 1 到 4 之间的数字:'
echo '你输入的数字为:'
read aNum
case $aNum in
    1)  echo '你选择了 1'
    ;;
    2)  echo '你选择了 2'
    ;;
    3)  echo '你选择了 3'
    ;;
    4)  echo '你选择了 4'
    ;;
    *)  echo '你没有输入 1 到 4 之间的数字'
    ;;
esac
```

case 工作方式如上所示，取值后面必须为单词 **in**，每一模式必须以右括号结束。取值可以为变量或常数，匹配发现取值符合某一模式后，其间所有命令开始执行直至 **;;**。

取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号` * `捕获该值，再执行后面的命令。

### 4. 函数

#### 4.1 函数定义

linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。

```bash
funWithReturn(){
    echo "这个函数会对输入的两个数字进行相加运算..."
    echo "输入第一个数字: "
    read aNum
    echo "输入第二个数字: "
    read anotherNum
    echo "两个数字分别为 $aNum 和 $anotherNum !"
    return $(($aNum+$anotherNum))
}
funWithReturn
echo "输入的两个数字之和为 $? !"
```

说明：

- 1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。
- 2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255

#### 4.2 函数参数

在Shell中，调用函数时可以向其传递参数。在函数体内部，通过` $n` 的形式来获取参数的值，例如，`$1`表示第一个参数，`$2`表示第二个参数...

```bash
funWithParam(){
    echo "第一个参数为 $1 !"
    echo "第二个参数为 $2 !"
    echo "第十个参数为 $10 !"
    echo "第十个参数为 ${10} !"
    echo "第十一个参数为 ${11} !"
    echo "参数总数有 $# 个!"
    echo "作为一个字符串输出所有参数 $* !"
}
funWithParam 1 2 3 4 5 6 7 8 9 34 73
```

注意，`$10` 不能获取第十个参数，获取第十个参数需要`${10}`。当n>=10时，需要使用`${n}`来获取参数。

另外，还有几个特殊字符用来处理参数：

| 参数处理 | 说明                                                         |
| :------- | :----------------------------------------------------------- |
| `$#`     | 传递到脚本或函数的参数个数                                   |
| `$*`     | 以一个单字符串显示所有向脚本传递的参数                       |
| `$$`     | 脚本运行的当前进程ID号                                       |
| `$!`     | 后台运行的最后一个进程的ID号                                 |
| `$@`     | 与`$*`相同，但是使用时加引号，并在引号中返回每个参数。       |
| `$-`     | 显示Shell使用的当前选项，与set命令功能相同。                 |
| `$?`     | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 |

### 5. 输入输出重定向



### 6. shell脚本编程经典实例

#### 6.1 无人值守下运行耗时作业

如果想在后台运行作业并在该作业完成前退出 shell，那就需要对作业使用 nohup。

```bash
root@ubuntu:~$ nohup tail -f examples.desktop &
[1] 2812
root@ubuntu:~$ nohup: ignoring input and appending output to 'nohup.out'
```

将作业置入后台时，它仍旧是 bash shell 的子进程。如果退出 shell 的某个实例，bash 就会向其所有子进程发送 hangup 信号。这就是作业运行不了多久的原因。只要退出bash，后台作业就会被“杀死”。

nohup 命令只是设置子进程忽略 hangup 信号。你仍可以用 kill 命令“杀死”作业，因为 kill 发送的是 SIGTERM 信号，而非 SIGHUP 信号。但有了 nohup，作业就不会在退出 bash 时被无意间“杀死”。

nohup 会替你重定向输出，将其追加（不是覆盖，而是添加到文件现有内容的末尾）到当前目录下的 nohup.out 文件中。你也可以明确地在命令行上指定将输出重定向到其他地方。

#### 6.2 减少if语句的数量

在 bash 中使用` && `运算符，根据条件执行命令。

```bash
cd mytmp && rm * -rf
```

用 `&& `分隔两个命令，以此告诉 bash 先执行第一个命令，如果该命令成功（退出状态为 0），再执行第二个命令。这非常类似于用 if 语句检查第一个命令的退出状态，从而判断是否执行第二个命令。

与`&&`类似，`||`表示前一个命令执行失败后，才执行后面的命令，通常用于故障时显示错误信息。

```bash
cmd || printf "%b" "cmd failed."
```

警告！千万别被下面这条语句骗了。

```shell
cmd || printf "%b" "cmd failed.";exit 1
```

exit无论如何都不会执行！`||` 仅作用于前两个命令。如果只想在 cmd 出错时执行 exit，那么要将其与 printf 分组到一起，以便两者被视为一个单元。语法如下所示：

```bash
cmd || { printf "%b" "cmd failed.";exit 1; }
```

注意，最后一个命令必须以分号结尾，闭合花括号与其中的内容之间要用空白字符分隔。

