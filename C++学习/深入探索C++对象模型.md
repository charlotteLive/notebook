# 深入探索C++对象模型

## 1. 



## 2. 构造函数语义学

### 2.1 默认构造函数


```C++
class Foo {
public: int val; Foo* pNext;
};

int main() {
    Foo tmp;
    if (tmp.val || tmp.pNext)
    {
        cout << "it's my expect." << endl;
    }
    else
    {
        cout << "it's not my expect." << endl;
    }
}
```

上述程序片段并不会合成出一个default constructor，甚至在部分编译器上会出现“使用了未初始化变量tmp”的错误。为了让上面的代码正确执行，class Foo的设计者必须提供一个明显的default constructor，并将两个成员变量适当地初始化。

**对于class X，如果没有任何用户定义的构造函数，那么会有一个default constructor被暗中（implicitly）申明出来，一个被暗中生名出来的default constructor将是一个trivial（浅薄而无能，没啥用的）constructor。**

下面我们讨论下四种编译器会成成nontrivial default constructor地情况。

- **带有Default Constructor的类成员变量**。
  如果一个类没有任何构造函数，但它有一个memeber object，而后者有默认构造函数，那么这个类的implicit default constructor就是nontrivial的，编译器需要为这个类合成出一个默认构造函数。不过这个合成操作只有在构造函数真正需要被调用时才会发生。编译器合成的默认构造函数会以**内联**的方式完成。

- **带有Default Constructor的基类**。
  如果一个没有任何构造函数的类派生自一个带有默认构造函数的基类，那么这个派生类的默认构造函数会被是为nontrivial，并因此需要被合成出来。

- **带有一个虚函数的类**。
  如果一个类没有任何构造函数，但它声明或继承了一个虚函数，那么编译器这个类合成出一个默认构造函数。生成时，虚函数表会被编译器产生出来，其中含有类的虚函数地址；每个类对象中会有一个额外的虚函数指针被生成出来，指向虚函数表的地址。

- **带有一个虚基类的类**。



C++新手一般有两个常见的误解：

1. 任何class如果没有定义默认构造函数，那么编译器就会合成出来一个；
2. 编译器合成出来的默认构造函数会明确设定类中每一个成员变量的默认值。

如你所见，没有一个是真的！

在合成的默认构造函数中，只有基类对象和类成员对象会被初始化，所有其他非静态成员变量，如整数、指针、数组等等都不会被初始化。这些初始化操作对成员而言或许需要，但对于编译器则并非必要。**如果一个程序需要一个“把某指针设为0”的默认构造函数，那么提供它的人应该时类的设计者**。

### 2.2 拷贝构造函数





### 2.3 成员初始化列表

